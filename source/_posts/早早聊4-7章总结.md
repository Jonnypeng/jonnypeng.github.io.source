---
title: 早早聊4-7章总结
date: 2021-09-30 14:27:25
tags:
---

## 1.如何做出专家级别的技术与技术产品规划
* 为什么要做规划？捷径=少走弯路.before.(更早的知道下一个阶段要做什么，主动避开一些没必要踩的坑).before 学会做规划.after(有规划的写代码)

* 常⽤用的⽅方法
  1. 追问法 
  2. 关键词联想搜索法 
  3. 分维度思考法 
  4. 不不重复不不遗漏漏

* 常见的分析维度
  1. 发展历史⻆角度
  2. 数据分析⻆角度
  3. ⽤用户价值⻆角度
  4. 未来预判⻆角度
  5. 顶层设计衔接⻆角度
  6. 竞品分析⻆角度

* 常犯的错误
  1. 没啥问题
  2. 表⾯面现象当成问题

<!--more-->

怎么描述定位：⾯面向/围绕xx场景，通过xx⽅方式，实现/构 建xx解决⽅方案/产品，帮助/为/实现xxx⽤用 户创建/提供xx服务/价值/提升

一些要点：
  1. 找定位的过程可以理理解为找差异化价值的过 程
  2. 过程中需要着重思考的是哪些事情是再难也 ⼀一定要做的，哪些事情是再简单也不不做的
  3. 而有些事情，尽管我们不不做，也是⼀一定要想 清楚为什什么不不做的

怎么定⽬目标
  1. 目标设计是什什么时候把这件事情/事情的价值做到什什么程度的设计
  2. 目标⼀一般分为定性和定量量两种，定量量就是可以⽤用确定的数字描述的 3. ⽬目标需要做量量化拆解，⼀一般有两种形式:⼦子⽬目标、⾥里里程碑碑⽬目标

一些要点：
  1. 目标设计和如何衡量量⽬目标是否达成是两件事 
  2. 好的⽬目标⼀一般都简单明确，易易于理理解
  3. 有时候⽬目标很难推导出来?那就粗暴暴的拍⼀一个

架构设计时的⼤大体思路路
  1. 每个架构图都有⼀一个主题或者说架构⽬目标;要能说清楚架构要解决的问题是什什么;
  2. 围绕架构⽬目标，从多维度的技术⻆角度列列举功能模块，做到不不遗漏漏不不重复;
  3. 理理清不不同维度、类别的模块之间的关系;做到逻辑⾃自洽;内容⻆角⾊色之间的关系讲的清楚;关系本身有很多种，常⻅见的是分层、流 程、组合、调⽤用、服务、抽象、继承、穿透、递进、分离、注册、集成...;过程中⼀一般可以按照⽤用户操作，数据流向，渲染机制， 承接关系，透出内容等来思考。
  4. 针对关系中的核⼼心问题设计解决⽅方案;
  5. 拿⼏几个实际的问题或者案例例套进去，看能不不能跑起来，或者细化架构中的接⼝口，开发模式等。

## 2.前端监控的设计实现和应⽤用

#### 微信⼩小程序
* 网络请求：代理全局对象WX的wx。request方法
* 页面跳转：覆写Page对象，代理其生命周期方法

#### React
1.JS 端
错误捕获
* ErrorUtils.setGlobalHandler 类似于 window.onerror
* Promise.rejectionTracking 类似于 Unhandledrejection ⽹网络请求:替换 XMLHttpRequest，代理理其 send/open/onload 等⽅方法
⽹网络请求:替换 XMLHttpRequest，代理理其 send/open/onload 等⽅方法
⻚页⾯面跳转:react-navigation 的 onStateChange 或者在 redux 集成⽅方 式中使⽤用 screenTracking

2.Native 端
* iOS 使⽤用 KSCrash 进⾏行行⽇日志采集，可以本地进⾏行行符号化
* 存储捕获到的数据(包括 JS 端和 native 端)统⼀一上报


## 3.serverless 
算力、算法、数据是程序开发三大先决条件，无服务器云计算(Serverless Computing)几乎封装了所有的底层资源管理和系统运维工作，使开发人员更容易使用云基础设施。 Serverless它提供了一个方式，极大地简化了基于云服务的编程，犹如汇编语言到高级编程语言般的转换。

Serverless从物理机到虚拟机，再到容器，再到函数，而FaaS是一个以“业务执行”为粒度的“算力”分配方式，是对全部底层资源和操作的封装，让开发者专注于业务逻辑。

Serverless的价值

1、降低运维需求：
Serverless 使得应用与服务器解耦，业务上线前无需预估资源，无需进行服务器购买、配置；
Serverless 也使得底层运维工作量进一步降低，业务上线后，也无需担忧服务器运维，而是全部交给了云平台或云厂商；

2、降低运营成本：
Serverless 的应用是按需执行的。应用只在有请求需要处理或者事件触发时才会被加载运行，在空闲状态下 Serverless 架构的应用本身并不占用计算资源；
而在使用 Serverless 产品时，用户只需要为处理请求的计算资源付费，而无须为应用空闲时段的资源占用付费；

3、缩短迭代周期、上线时间：
Serverless 架构带来的是进一步的业务解耦，应用功能被解构成若干个细颗粒度的无状态函数，开发可以聚焦在单功能的快速开发和上线上；
同时拆解后的云函数，也都可以进行独立的迭代升级，更快速的实现业务迭代，缩减功能的上市时间；

4、快速试错
利用 Serverless 架构的简单运维、低成本及快速上线能力，可以来快速尝试业务的新形态、新功能；
利用 Serverless 产品的强弹性扩容能力，在业务获得成功时，也无需为资源扩容而担心；

## 4.微前端

什么是微前端？

微前端是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立运行、独立开发、独立部署。微前端不是单纯的前端框架或者工具，而是一套架构体系。

Icestark的微前端实践

架构设计

![架构图](https://pic3.zhimg.com/80/v2-ad82366717369e4ed5fa32ee6d30b582_720w.jpg)

如上图所示，首先引入框架应用和子应用的概念，框架应用负责系统整体布局以及子应用的注册、加载与渲染，同时在设计原则上我们希望「子应用尽量保持跟传统单页面应用一样的开发体验」，保证子应用自身可独立运行、存量应用可快速迁移适配、增量应用跟传统方式开发体验一致。

在确认上述核心设计思路之后，接下来就是对问题进行具体拆解：子应用是一个传统的 SPA 应用（可包含一个或多个页面），会打包出 bundle 同时发布到 CDN，那么我们需要在框架应用中注册管理所有子应用，然后在适当的时机加载对应的子应用 bundle 并将其渲染到指定节点（系统布局里面）。在这个流程里核心要解决的技术问题如下。

1. 什么时候加载哪个子应用？
子应用包含多个页面即路由，只有页面路由的变化会引起子应用的切换，那么我们只要建立子应用和路由的映射关系即可。为每个子应用分配一个基准路由如 /seller ，这个子应用保证所有的路由定义在 /seller 下，那么当从其他路由跳转到 /seller 路由时我们就可以加载渲染 /seller 对应的子应用 bundle 了。PS：除了基准路由这种约束方式也支持其他更加松散的方式。

2. 如何捕获到系统中所有路由的变化？
icestark 通过劫持 history.pushState 和 history.replaceState 两个 API，同时监听 popstate 事件，保证能够捕获到到所有路由变化。当捕获到路由变化时，根据路由查找对应的子应用，如果对应的还是当前这个子应用则什么事情都不做，如果对应的是新的一个子应用则卸载之前的子应用，同时加载新的子应用并渲染之。

3. 如何将子应用的 bundle 渲染到指定节点？
框架应用有系统的 Layout，我们需要将子应用渲染到 Layout 里面，但是单页面应用都是直接通过 ReactDOM.render(<App />, document.getElementById('#root')) 的方式渲染，如果直接执行那么渲染的位置是无法被控制的，于是 icestark 为子应用提供了一个 getMountNode() 的 API 保证子应用能够渲染到指定的节点里。

4. 子应用使用不同的前端框架怎么办？
在我们内部使用时其实并没有考虑这个问题，因为我们内部目前都是 React 的技术栈，基本不存在这样的问题，但是如果要将这个方案开源，那这个特性是必须支持的。

比较有意思的是回顾上述的核心设计，icestark 对子应用的约束非常简单：路由需要规范最好是通过基准路由约束、需要渲染到指定节点里，那么子应用是通过 Vue 或者 ReactDOM 亦或是 jQuery 渲染都无所谓了，整体方案对此没有任何依赖。
